<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="author" content="Szymon Stepniak"><meta name="robots" content="all"><title>Groovy Trampoline Closure - a step into recursive closures</title><meta name="description" content="A few weeks ago an interesting question was asked on the StackOverflow. Someone experimented with a recursion in Groovy and stepped into Closure.trampoline() [1]. It quickly turned out that using TrampolineClosure makes a recursive execution slower. Is..."><meta name="keywords" content="groovy,recursion,jmh,benchmark,closures,tail-recursive"><link rel="shortcut icon" type="image/png" href="/favicon.png"><link rel="dns-prefetch" href="//cdnjs.cloudflare.com"><link rel="dns-prefetch" href="//maxcdn.bootstrapcdn.com"><link rel="dns-prefetch" href="//disqus.com"><link rel="dns-prefetch" href="//c.disquscdn.com"><link rel="canonical" href="https://e.printstacktrace.blog/groovy-trampoline-closure-a-step-into-recursive-closures/"><link rel="alternate" type="application/rss+xml" title="e.printStackTrace(); // Blog" href="/atom.xml"><link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/androidstudio.min.css"><link rel="stylesheet" href="/css/main.css?v=44"><link rel="stylesheet" href="/css/conum.css?v=44"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Noto+Serif:400,700,400italic"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Droid+Sans+Mono:400,700"><meta name="description" content="A few weeks ago an interesting question was asked on the StackOverflow. Someone experimented with a recursion in Groovy and stepped into Closure.trampoline() [1]. It quickly turned out that using Tram"><meta property="og:type" content="article"><meta property="og:title" content="Groovy Trampoline Closure - a step into recursive closures"><meta property="og:url" content="https://e.printstacktrace.blog/groovy-trampoline-closure-a-step-into-recursive-closures/"><meta property="og:site_name" content="e.printStackTrace(); &#x2F;&#x2F; Blog"><meta property="og:description" content="A few weeks ago an interesting question was asked on the StackOverflow. Someone experimented with a recursion in Groovy and stepped into Closure.trampoline() [1]. It quickly turned out that using Tram"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://e.printstacktrace.blog/images/og/groovy-trampoline-closure.jpg"><meta property="article:published_time" content="2019-06-25T11:54:04.000Z"><meta property="article:modified_time" content="2019-06-25T11:54:04.000Z"><meta property="article:author" content="Szymon Stepniak"><meta property="article:tag" content="groovy"><meta property="article:tag" content="recursion"><meta property="article:tag" content="jmh"><meta property="article:tag" content="benchmark"><meta property="article:tag" content="closures"><meta property="article:tag" content="tail-recursive"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://e.printstacktrace.blog/images/og/groovy-trampoline-closure.jpg"><meta name="twitter:creator" content="@wololock"><script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://e.printstacktrace.blog/groovy-trampoline-closure-a-step-into-recursive-closures/"},"headline":"Groovy Trampoline Closure - a step into recursive closures","image":{"@type":"ImageObject","url":"https://e.printstacktrace.blog/images/og/groovy-trampoline-closure.jpg"},"datePublished":"2019-06-25T11:54:04.000Z","dateModified":"2019-06-25T11:54:04.000Z","author":{"@type":"Person","name":"Szymon Stepniak"},"publisher":{"@type":"Organization","name":"e.printStackTrace(); // Blog","logo":{"@type":"ImageObject","url":"https://e.printstacktrace.blog/images/site-logo.jpg","height":60,"width":600}},"description":"A few weeks ago an interesting question was asked on the StackOverflow. Someone experimented with a recursion in Groovy and stepped into Closure.trampoline() [1]. It quickly turned out that using TrampolineClosure makes a recursive execution slower. Is this a valid behavior, or do we do something wrong?","keywords":"groovy,recursion,jmh,benchmark,closures,tail-recursive"}</script><meta name="generator" content="Hexo 4.2.0"></head><body class="layout-post"><nav class="navbar navbar-default navbar-fixed-top navbar-custom"><div class="container-fluid"><div class="navbar-header"><button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#main-navbar"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><span>e.printStackTrace(); // Blog</span></a></div><div class="collapse navbar-collapse" id="main-navbar"><ul class="nav navbar-nav navbar-right"><li><a href="/archives">Archive</a></li><li><a href="/youtube">YouTube</a></li><li><a class="stack-overflow" href="https://stackoverflow.com/users/2194470/szymon-stepniak?tab=profile" target="_blank" rel="noopener"><img class="so-icon" src="/img/so.png"><b class="rep">25,933</b><span class="badges"><span class="gold"><span class="b">●</span><span class="c">9</span></span><span class="silver"><span class="b">●</span><span class="c">58</span></span><span class="bronze"><span class="b">●</span><span class="c">88</span></span></span></a></li><li><a href="https://twitter.com/wololock" target="_blank" rel="noopener"><img src="https://badgen.net/twitter/follow/wololock"></a></li><li><a href="https://circleci.com/gh/wololock/wololock.github.io/tree/develop" target="_blank" rel="noopener"><img src="https://badgen.net/circleci/github/wololock/wololock.github.io/develop?icon=circleci&amp;label"></a></li></ul></div></div></nav><header class="header-section"><div class="intro-header" style="background-image:url(/img/post-bg-1.jpg)"><div class="container"><div class="row"><div class="col-lg-10 col-lg-offset-1 col-md-10 col-md-offset-1"><div class="post-heading"><a class="category" href="/categories/groovy-cookbook/">Groovy Cookbook</a><h1>Groovy Trampoline Closure - a step into recursive closures</h1><div class="post-meta"><ul><li><time datetime="2019-06-25T11:54:04.000Z" itemprop="datePublished">Jun 25, 2019</time></li><li>10 minutes read</li><li><a href="https://e.printstacktrace.blog/groovy-trampoline-closure-a-step-into-recursive-closures/#disqus_thread">0 Comments</a></li></ul><section class="post-tags"><ul class="tags"><li><a class="tag post-meta" href="/tags/groovy/">groovy</a></li><li><a class="tag post-meta" href="/tags/recursion/">recursion</a></li><li><a class="tag post-meta" href="/tags/jmh/">jmh</a></li><li><a class="tag post-meta" href="/tags/benchmark/">benchmark</a></li><li><a class="tag post-meta" href="/tags/closures/">closures</a></li><li><a class="tag post-meta" href="/tags/tail-recursive/">tail-recursive</a></li></ul></section></div></div></div></div></div></div></header><div class="container"><div class="row"><div class="col-lg-10 col-lg-offset-1 col-md-10 col-md-offset-1"><article class="blog-post" role="main"><div class="paragraph"><p>A few weeks ago an interesting question was <a href="https://stackoverflow.com/q/56578937/2194470" target="_blank" rel="noopener">asked on the StackOverflow</a>. Someone experimented with a recursion in Groovy and stepped into <code>Closure.trampoline()</code> <sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup>. It quickly turned out that using <code>TrampolineClosure</code> makes a recursive execution slower. Is this a valid behavior, or do we do something wrong?</p></div><a id="more"></a><div class="sect1"><h2 id="why-closure-trampoline">Why <code>Closure.trampoline()</code>?</h2><div class="sectionbody"><div class="paragraph"><p>Recursive algorithms in Groovy (or Java in general) are quite tricky. Every recursive call adds a frame to the call stack. If we make too many recursive calls, we can hit the call stack limit and cause <code>StackOverflowError</code>. We used to use recursive method calls, but the same problem applies to recursive closure calls. Consider the following example.</p></div><div class="listingblock"><div class="title">Listing 1. Recursive factorial function defined as a closure</div><div class="content"><pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">def factorial
factorial = { n, acc = 1G -&gt; 1 &gt;= n ? acc : factorial(n - 1, acc * n ) } <i class="conum" data-value="1"></i><b>(1)</b>

assert factorial(13) == 6227020800</code></pre></div></div><div class="paragraph"><p>In this simple Groovy snippet we define a recursive closure call <em class="conum" data-value="1"></em> to compute the factorial of a given number. This recursive closure allows me to compute factorial of <code>706</code>, but it hits the <code>StackOverflowError</code> for any number starting from <code>707</code>.</p></div><div class="paragraph"><p>This is where <code>TrampolineClosure</code> comes with a help.</p></div><div class="quoteblock"><blockquote><div class="paragraph"><p>Closures are wrapped in a <code>TrampolineClosure</code>. Upon calling, a trampolined <code>Closure</code> will call the original <code>Closure</code> waiting for its result. If the outcome of the call is another instance of a <code>TrampolineClosure</code>, created perhaps as a result to a call to the <code>trampoline()</code> method, the <code>Closure</code> will again be invoked. This repetitive invocation of returned trampolined <code>Closures</code> instances will continue until a value other than a trampolined <code>Closure</code> is returned. That value will become the final result of the trampoline. That way, calls are made serially, rather than filling the stack.</p><hr>Source: <a href="http://groovy-lang.org/closures.html#_trampoline" target="_blank" rel="noopener" class="bare">http://groovy-lang.org/closures.html#_trampoline</a><p></p></div></blockquote></div><div class="paragraph"><p>The above example refactored to the trampoline version may look like this:</p></div><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">def factorial
factorial = { n, acc = 1G -&gt; 1 &gt;= n ? acc : factorial.trampoline(n - 1, acc * n ) }.trampoline()

assert factorial(13) == 6227020800</code></pre></div></div><div class="paragraph"><p>The <code>TrampolineClosure</code> makes all recursive calls serial, so in this case computing factorial of numbers larger than <code>707</code> is doable.</p></div></div></div><div class="sect1"><h2 id="the-performance">The performance</h2><div class="sectionbody"><div class="paragraph"><p>What about the performance? Running a quick JMH benchmark shows that:</p></div><div class="ulist"><ul><li><p>computing <code>factorial(500)</code> without the trampoline takes <strong>0.111 ms</strong> (in average) on my computer</p></li><li><p>computing <code>factorial(500)</code> with the trampoline takes <strong>0.196 ms</strong> (in average) on my computer</p></li></ul></div><div class="paragraph"><p>For a single call the difference is not huge. However, in the question asked on the StackOverflow we had to deal with a slightly different scenario. The person who asked this question compared the execution time of computing factorial 100,000 times for a pseudo-random number between 0 and 39.</p></div><div class="admonitionblock important"><table><tr><td class="icon"><i class="fa icon-important" title="Important"></i></td><td class="content"><strong>REMEMBER:</strong> The numbers below are just data. To gain reusable insights, you need to follow up on why the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial experiments, perform baseline and negative tests that provide experimental control, make sure the benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts. Do not assume the numbers tell you what you want them to tell.</td></tr></table></div></div></div><div class="sect1"><h2 id="the-benchmark">The benchmark</h2><div class="sectionbody"><div class="paragraph"><p>I created a benchmark that simulates a very similar scenario. In this test we benchmark the execution of calculating factorial 100,000 time using pseudo-random numbers from range <code>&lt;30,34&gt;</code>. This way we can eliminate anomalies (e.g. calculating <code>factorial(0)</code> or <code>factorial(1)</code>) and prevent JIT compiler from inlining method call with fixed argument.</p></div><div class="admonitionblock note"><table><tr><td class="icon"><i class="fa icon-note" title="Note"></i></td><td class="content">You can clone the JMH benchmark test source code from: <a href="https://github.com/wololock/groovy-closure-trampoline-example" target="_blank" rel="noopener" class="bare">https://github.com/wololock/groovy-closure-trampoline-example</a></td></tr></table></div><div class="paragraph"><p>The benchmark tests the following scenarios:</p></div><div class="ulist"><ul><li><p>calculating factorial using recursive closure call,</p></li><li><p>calculating factorial using recursive trampoline closure call,</p></li><li><p>calculating factorial using tail recursive method.</p></li></ul></div><div class="paragraph"><p>Each scenario is tested in the dynamic and statically compiled variant.</p></div><div class="listingblock"><div class="title">Listing 2. JMH benchmark test of a factorial function defined with closures</div><div class="content"><pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">package bench

import groovy.transform.CompileStatic
import groovy.transform.TailRecursive
import org.openjdk.jmh.annotations.Benchmark
import org.openjdk.jmh.annotations.Scope
import org.openjdk.jmh.annotations.State

@State(Scope.Benchmark)
class FactorialBench {

    static final Random random = new Random()
    static final int limit = 100000

    @Benchmark
    void a_standard() {
        def factorial
        factorial = { n, acc = 1G -&gt; 1 &gt;= n ? acc : factorial(n - 1, acc * n ) }

        for (int i = 0; i &lt; limit; i++) {
            factorial(30 + random.nextInt(5))
        }
    }

    @Benchmark
    @CompileStatic
    void a_standard_sc() {
        Closure factorial
        factorial = { int n, acc = 1G -&gt; 1 &gt;= n ? acc : factorial(n - 1, ((BigInteger) acc) * BigInteger.valueOf((long) n)) }

        for (int i = 0; i &lt; limit; i++) {
            factorial(30 + random.nextInt(5))
        }
    }

    @Benchmark
    void b_trampoline() {
        def factorial
        factorial = { n, acc = 1G -&gt; 1 &gt;= n ? acc : factorial.trampoline(n - 1, acc * n ) }.trampoline()

        for (int i = 0; i &lt; limit; i++) {
            factorial(30 + random.nextInt(5))
        }
    }

    @Benchmark
    @CompileStatic
    void b_trampoline_sc() {
        Closure factorial
        factorial = { int n, acc = 1G -&gt; 1 &gt;= n ? acc : factorial.trampoline(n - 1, ((BigInteger) acc) * BigInteger.valueOf((long) n)) }.trampoline()

        for (int i = 0; i &lt; limit; i++) {
            factorial(30 + random.nextInt(5))
        }
    }

    @Benchmark
    void c_tailRecursive() {
        for (int i = 0; i &lt; limit; i++) {
            factorialTailRecursive(30 + random.nextInt(5))
        }
    }

    @Benchmark
    @CompileStatic
    void c_tailRecursive_sc() {
        for (int i = 0; i &lt; limit; i++) {
            factorialTailRecursiveSC(30 + random.nextInt(5))
        }
    }


    @TailRecursive
    static factorialTailRecursive(n, acc = 1G) {
        1 &gt;= n ? acc : factorialTailRecursive(n - 1, n * acc)
    }

    @TailRecursive
    @CompileStatic
    static BigInteger factorialTailRecursiveSC(int n, BigInteger acc = 1G) {
        1 &gt;= n ? acc : factorialTailRecursiveSC(n - 1, acc * BigInteger.valueOf((long) n))
    }
}</code></pre></div></div><div class="paragraph"><p>I use JMH Gradle plugin, so executing the following benchmark looks like this:</p></div><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ ./gradlew clean jmh --no-daemon</code></pre></div></div></div></div><div class="sect1"><h2 id="the-results">The results</h2><div class="sectionbody"><div class="paragraph"><p>The execution of all benchmark scenarios takes about 8-9 minutes. I run it twice for Groovy 2.5.7 and for Groovy 3.0.0-beta-1 just to check if the upcoming version 3 introduces any performance improvements.</p></div><div class="admonitionblock note"><table><tr><td class="icon"><i class="fa icon-note" title="Note"></i></td><td class="content">Laptop specs: JDK 1.8.0_201 (Java HotSpot&#8482; 64-Bit Server VM, 25.201-b09), Groovy 2.5.7, Intel&#174; Core&#8482; i7-4900MQ CPU @ 2.80GHz (4 cores, cache size 8192 KB), 16 GB RAM, OS: Fedora 29 (64 bit)</td></tr></table></div><div class="sect2"><h3 id="1-standard-recursive-closure">1) Standard recursive closure</h3><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">Benchmark                                 Mode  Cnt     Score   Error  Units
FactorialBench.a_standard                 avgt   42   472,114 ± 1,315  ms/op
FactorialBench.a_standard_sc              avgt   42   428,717 ± 1,063  ms/op</code></pre></div></div><div class="paragraph"><p>This is our starting point. We can see that running statically compiled code is approximately <strong>9%</strong>&nbsp;faster.</p></div><div class="paragraph"><p>And here is the <code>stack</code> profiler output.</p></div><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">....[Thread state: RUNNABLE]........................................................................
 43,6%  43,6% org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.pickClosureMethod
 21,6%  21,6% sun.reflect.DelegatingMethodAccessorImpl.invoke
 21,2%  21,2% org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite$PojoCachedMethodSiteNoUnwrap.invoke
  5,5%   5,6% groovy.lang.MetaMethod.doMethodInvoke
  3,6%   3,6% groovy.lang.MetaClassImpl.invokeMethod
  3,1%   3,1% sun.reflect.GeneratedMethodAccessor2.invoke
  0,4%   0,4% java.math.BigInteger.multiply
  0,3%   0,3% org.codehaus.groovy.runtime.ArrayUtil.createArray
  0,2%   0,2% java.util.Arrays.copyOf
  0,2%   0,2% java.util.Arrays.copyOfRange
  0,4%   0,4% &lt;other&gt;</code></pre></div></div></div><div class="sect2"><h3 id="2-trampoline-closure">2) Trampoline closure</h3><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">Benchmark                                 Mode  Cnt     Score   Error  Units
FactorialBench.b_trampoline               avgt   42  1054,703 ± 3,805  ms/op
FactorialBench.b_trampoline_sc            avgt   42   683,293 ± 2,191  ms/op</code></pre></div></div><div class="paragraph"><p>The benchmark test shows that the (dynamic) trampoline variant of the factorial function is about <strong>2.23 times</strong> slower compared to the standard recursive closure approach.</p></div><div class="paragraph"><p>Here is the <code>stack</code> profiler output for the trampoline closure variant:</p></div><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">....[Thread state: RUNNABLE]........................................................................
 22,6%  22,6% org.codehaus.groovy.reflection.ParameterTypes.isValidMethod
 21,8%  21,8% org.codehaus.groovy.reflection.ParameterTypes.coerceArgumentsToClasses
 15,5%  15,5% org.codehaus.groovy.reflection.ParameterTypes.correctArguments
 11,5%  11,5% groovy.lang.Closure.&lt;init&gt;
  9,4%   9,4% sun.reflect.DelegatingMethodAccessorImpl.invoke
  8,5%   8,5% groovy.lang.TrampolineClosure.&lt;init&gt;
  7,1%   7,1% org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.pickClosureMethod
  0,4%   0,4% groovy.lang.MetaClassImpl.invokeMethod
  0,3%   0,3% org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite$PojoCachedMethodSiteNoUnwrap.invoke
  0,3%   0,3% java.math.BigInteger.multiply
  2,6%   2,6% &lt;other&gt;</code></pre></div></div><div class="paragraph"><p>There are two major differences between trampoline and the standard recursive closure:</p></div><div class="ulist"><ul><li><p>Creating <code>TrampolineClosure</code> objects for each recursive call comes with a cost. In this specific case it took <strong>210.8 ms</strong> (20% of the total time).</p></li><li><p>Calling <code>Closure.trampoline(args)</code> requires arguments coercion, which takes <strong>~393 ms</strong> (37.3% of the total time).</p></li></ul></div><div class="paragraph"><p>Static compilation helps a bit - it executes in <strong>683.293 ms</strong> average time. If we take a look at the call stack from the profiler, we see that static compilation removed the need of the arguments coercion. The main additional cost comes with the <code>TrampolineClosure</code> objects creation - it takes <strong>185.172 ms</strong> (27,1% of the total time).</p></div><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">....[Thread state: RUNNABLE].....................................................................
 29,2%  29,2% org.codehaus.groovy.reflection.ParameterTypes.isValidMethod
 24,5%  24,5% java.math.BigInteger.multiply
 16,7%  16,7% groovy.lang.Closure.&lt;init&gt;
 10,4%  10,4% groovy.lang.TrampolineClosure.&lt;init&gt;
  9,8%   9,8% org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.pickClosureMethod
  4,0%   4,0% org.codehaus.groovy.runtime.metaclass.MetaMethodIndex.getMethods
  2,4%   2,4% org.codehaus.groovy.reflection.ParameterTypes.correctArguments
  0,7%   0,7% sun.reflect.GeneratedMethodAccessor1.invoke
  0,5%   0,5% groovy.lang.MetaClassImpl.invokeMethod
  0,3%   0,3% java.util.Arrays.copyOf
  1,3%   1,3% &lt;other&gt;</code></pre></div></div></div><div class="sect2"><h3 id="3-tail-recursive-method">3) Tail recursive method</h3><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">Benchmark                                 Mode  Cnt     Score   Error  Units
FactorialBench.c_tailRecursive            avgt   42   322,019 ± 1,409  ms/op
FactorialBench.c_tailRecursive_sc         avgt   42   104,385 ± 1,380  ms/op</code></pre></div></div><div class="paragraph"><p>The best performance comes with a tail recursive method. And it shouldn&#8217;t be a surprise - Groovy compiler compiles a method annotated with <code>@TailRecursive</code> to a bytecode that uses while-loop instead of the recursive calls. <em>(Read more about in the <a href="/tail-recursive-methods-in-groovy/" title="Tail-recursive methods in Groovy">Tail-recursive methods in Groovy</a> post.)</em> That is why the call stack is dominated by two operations:</p></div><div class="ulist"><ul><li><p><code>java.math.BigInteger</code> object initialization,</p></li><li><p>and <code>java.math.BigInteger.multiply()</code> method call.</p></li></ul></div><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">....[Thread state: RUNNABLE]........................................................................
 41,5%  41,5% java.math.BigInteger.&lt;init&gt;
 26,8%  26,8% java.math.BigInteger.multiply
 15,9%  15,9% java.lang.Integer.getChars
 14,2%  14,2% java.lang.Integer.stringSize
  0,5%   0,5% java.math.BigInteger.multiplyByInt
  0,3%   0,3% bench.FactorialBench.factorialTailRecursive
  0,2%   0,2% java.lang.Integer.toString
  0,2%   0,2% org.codehaus.groovy.runtime.typehandling.NumberMath.toBigInteger
  0,2%   0,2% java.util.Arrays.copyOfRange
  0,0%   0,0% org.openjdk.jmh.runner.BenchmarkHandler$BenchmarkTask.call</code></pre></div></div><div class="paragraph"><p>The statically compiled variant of the tail recursive method does even better. In this case it spends 97.1% of the time calling <code>NumberMath.multiply</code>.</p></div><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">....[Thread state: RUNNABLE]........................................................................
 97,1%  97,2% org.codehaus.groovy.runtime.typehandling.NumberMath.multiply
  1,1%   1,1% bench.FactorialBench.factorialTailRecursiveSC
  0,8%   0,8% java.math.BigInteger.multiplyByInt
  0,2%   0,2% java.math.BigInteger.valueOf
  0,2%   0,2% bench.FactorialBench.c_tailRecursive_sc
  0,2%   0,2% java.util.Arrays.copyOfRange
  0,1%   0,1% java.lang.Thread.isInterrupted
  0,1%   0,1% java.math.BigInteger.&lt;init&gt;
  0,1%   0,1% java.lang.System.nanoTime
  0,0%   0,0% sun.misc.Unsafe.unpark</code></pre></div></div></div></div></div><div class="sect1"><h2 id="does-groovy-3-0-0-beta-1-do-better">Does Groovy <code>3.0.0-beta-1</code> do better?</h2><div class="sectionbody"><div class="paragraph"><p>Short answer - no. The results comparable. Even if Groovy 2.5.7 of 3.0.0-beta-1 does a little bit better in one variant or another, it doesn&#8217;t prove anything. The tendencies are the same in both cases.</p></div><div class="openblock text-center"><div class="content"><div class="imageblock img-responsive img-thumbnail"><div class="content"><a class="image" href="/images/groovy-trampoline-01.png"><img src="/images/groovy-trampoline-01.png" alt="groovy trampoline 01"></a></div></div></div></div><div class="admonitionblock note"><table><tr><td class="icon"><i class="fa icon-note" title="Note"></i></td><td class="content"><div class="paragraph"><p>Here you can find the full console output from the benchmark tests I use:</p></div><div class="ulist"><ul><li><p><a href="https://gist.github.com/wololock/6e3c52785c412ef19444ecc549489110" target="_blank" rel="noopener">Groovy 2.5.7 output</a></p></li><li><p><a href="https://gist.github.com/wololock/4062fd3916c3278c27f60b21446fe5bf" target="_blank" rel="noopener">Groovy 3.0.0-beta-1 output</a></p></li></ul></div></td></tr></table></div></div></div><div class="sect1"><h2 id="conclusion">Conclusion</h2><div class="sectionbody"><div class="paragraph"><p>The final question is - should we avoid using <code>Closure.trampoline()</code> then? <strong>Absolutely not.</strong> If you use recursive calls in the closure, you should consider using the <code>TrampolineClosure</code> to avoid hitting the call stack size limit. The cost of using <code>TrampolineClosure</code> in the statically compiled Groovy code becomes a trouble only when you need to handle hundreds of thousands calls that invoke recursive closure. However, in this case you can also consider refactoring to the tail recursive method call for the best performance. But remember what Donald Knuth said: <em>"Premature optimization is the root of all evil."</em> <sup class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnotedef_2" title="View footnote.">2</a>]</sup> <span class="icon"><i class="fa fa-smile-o"></i></span> Use whatever programming construction that works for you (and your team) best, and solve performance problems when they start occurring.</p></div></div></div><div id="footnotes"><hr><div class="footnote" id="_footnotedef_1"><a href="#_footnoteref_1">1</a>. <a href="http://groovy-lang.org/closures.html#_trampoline" target="_blank" rel="noopener" class="bare">http://groovy-lang.org/closures.html#_trampoline</a></div><div class="footnote" id="_footnotedef_2"><a href="#_footnoteref_2">2</a>. Donald Knuth, "Computer Programming as an Art (1974)", p. 671</div></div><h2>Thank you!</h2><p>If you read up to this point - leave me a comment below. It means a lot to me to hear your opinion. Share this blog post on <a href="https://twitter.com/intent/tweet?text=%22Groovy%20Trampoline%20Closure%20-%20a%20step%20into%20recursive%20closures%22%20https://e.printstacktrace.blog/groovy-trampoline-closure-a-step-into-recursive-closures/%20via%20@wololock" title="Twitter" target="_blank" rel="noopener">Twitter</a>, <a href="https://www.facebook.com/sharer/sharer.php?u=https://e.printstacktrace.blog/groovy-trampoline-closure-a-step-into-recursive-closures/&t=Groovy%20Trampoline%20Closure%20-%20a%20step%20into%20recursive%20closures" title="Facebook" target="_blank" rel="noopener">Facebook</a>, or <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://e.printstacktrace.blog/groovy-trampoline-closure-a-step-into-recursive-closures/&title=Groovy%20Trampoline%20Closure%20-%20a%20step%20into%20recursive%20closures" title="LinkedIn" target="_blank" rel="noopener">LinkedIn</a>, if you found it helpful.</p><p>I will be very grateful if you consider <a href="/support-me">supporting</a> my work and effort. I run this blog to share my experience, inspire, and help other people to become better problem solvers.</p><footer class="post-footer"><img class="img-responsive img-circle" src="https://www.gravatar.com/avatar/b22c1842c6e8f7f2b9b3ed8c0d4efb4d?s=200"><div class="row author"><div class="col-lg-8 col-lg-offset-2 col-xs-10 col-xs-offset-1"><h4>Szymon Stepniak</h4><p><a class="stack-overflow" href="https://stackoverflow.com/users/2194470/szymon-stepniak?tab=profile" target="_blank" rel="noopener"><img class="so-icon" src="/img/so.png"><b class="rep">25,933</b><span class="badges"><span class="gold"><span class="b">●</span><span class="c">9</span></span><span class="silver"><span class="b">●</span><span class="c">58</span></span><span class="bronze"><span class="b">●</span><span class="c">88</span></span></span></a></p><p>Groovista, Upwork's Top Rated freelancer, Toruń Java User Group founder, open&nbsp;source contributor, Stack Overflow addict, bedroom guitar player. I walk through e.printStackTrace() so you don't have to.</p><ul class="social-links"><li><a href="https://feeds.feedburner.com/Eprintstacktracenet" target="_blank" rel="noopener" onclick="return window.open(this.href),!1"><span class="fa fa-rss"></span></a></li><li><a href="https://twitter.com/wololock" target="_blank" rel="noopener" onclick="return window.open(this.href),!1"><span class="fa fa-twitter"></span></a></li><li><a href="https://github.com/wololock" target="_blank" rel="noopener" onclick="return window.open(this.href),!1"><span class="fa fa-github"></span></a></li><li><a href="https://stackoverflow.com/users/2194470/szymon-stepniak?tab=profile" target="_blank" rel="noopener" onclick="return window.open(this.href),!1"><span class="fa fa-stack-overflow"></span></a></li><li><a href="https://www.youtube.com/channel/UCEf8e5YAYnowq-2deW4tpsw/featured" target="_blank" rel="noopener" onclick="return window.open(this.href),!1"><span class="fa fa-youtube"></span></a></li><li><a href="mailto:szymon.stepniak@gmail.com" onclick="return window.open(this.href),!1"><span class="fa fa-envelope"></span></a></li><li><a href="https://www.linkedin.com/in/szymon-stępniak-9a0b1630" target="_blank" rel="noopener" onclick="return window.open(this.href),!1"><span class="fa fa-linkedin"></span></a></li><li><a href="https://keybase.io/wololock" target="_blank" rel="noopener" onclick="return window.open(this.href),!1"><span class="fa fa-user-secret"></span></a></li></ul></div></div></footer><section class="related-posts"><h2>You may also like</h2><div class="row"><div class="col-lg-4"><a href="/what-is-the-most-efficient-way-to-iterate-collection-in-groovy-jmh/"><img class="img-responsive" src="/images/og/groovy-jmh-benchmark.jpg"><h3>What is the most efficient way to iterate collection in Groovy? Let's play with JMH!</h3></a><p>I guess you may heard about Groovy&#8217;s Collection.each(Closure cl) method - it was introduced 15 years ago [1] and it was a great alternative for a good old for-loop, for-each or even using an ...</p></div><div class="col-lg-4"><a href="/tail-recursive-methods-in-groovy/"><img class="img-responsive" src="/images/og/groovy-tail-recursive.jpg"><h3>Tail-recursive methods in Groovy</h3></a><p>Most of the object-oriented programmers prefer constructing algorithms using imperative style over using recursion. This is pretty obvious in the JVM ecosystem, where imperative iteration is much m...</p></div><div class="col-lg-4"><a href="/groovy-regular-expressions-the-definitive-guide/"><img class="img-responsive" src="/images/og/groovy-regexp-jmh.jpg"><h3>Groovy Regular Expressions - The Definitive Guide</h3></a><p>I&#8217;ve never enjoyed working with regular expressions in Java. It was always very error-prone. You had to remember to escape backslashes, and a very simple match elements check required writing...</p></div></div></section></article><nav class="pagination" role="pagination"><a class="pull-left btn" href="/jenkins-pipeline-environment-variables-the-definitive-guide/">← Next post</a><a class="pull-right btn" href="/gr8conf-eu-2019-recap/">Previous post →</a></nav><div class="disqus-comments"><div class="comments"><div id="disqus_thread"></div></div></div><script>var url_parts=window.location.href.split("?"),disqus_url=url_parts[0];!function(){var t=document.createElement("script");t.type="text/javascript",t.async=!0,t.src="//eprintstacktrace.disqus.com/embed.js",(document.head||d.body).appendChild(t)}()</script></div></div></div><script async id="dsq-count-scr" src="//eprintstacktrace.disqus.com/count.js"></script><footer class="site-footer"><div class="container-fluid"><div class="row"><div class="col-lg-10 col-lg-offset-1 col-xs-10 col-xs-offset-1"><div class="row"><div class="col-lg-4"><h4 class="marked">Recent video on YouTube</h4><section class="recent-posts"><a href="https://www.youtube.com/watch?v=i9pNYW1Pg9A" target="_blank" rel="noopener"><img class="img-thumbnail img-noborder" src="https://i3.ytimg.com/vi/i9pNYW1Pg9A/mqdefault.jpg" alt="Groovy DSL Quickstart"></a></section><h4>e.printstacktrace.blog © 2020</h4><p><em>"I walk through e.printStackTrace() so you don't have to"</em></p></div><div class="col-lg-4"><h4 class="marked">Recent articles</h4><section class="recent-posts"><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/my-first-200-youtube-subscribers-thank-you/">My first 200 YouTube subscribers - Thank You!</a></li><li class="post-list-item"><a class="post-list-link" href="/groovy-dynamic-maps-generic-type-erasure-and-raw-types/">Groovy dynamic Maps, generic type erasure, and raw types - an interesting use case to learn from</a></li><li class="post-list-item"><a class="post-list-link" href="/groovy-3-nullcheck-annotation-less-code-and-less-npe/">Groovy 3 @NullCheck annotation - less code and less NPE</a></li><li class="post-list-item"><a class="post-list-link" href="/groovy-3-string-gdk-improvements-takeright-takebetween-and-a-few-others/">Groovy 3 String GDK improvements - takeRight, takeBetween, and a few others</a></li><li class="post-list-item"><a class="post-list-link" href="/jenkins-scripted-pipeline-vs-declarative-pipeline-the-4-practical-differences/">Jenkins Scripted Pipeline vs. Declarative Pipeline - the 4 practical differences</a></li><li class="post-list-item"><a class="post-list-link" href="/the-blog-development-report-year-2019/">The blog development report - year 2019</a></li></ul></section></div><div class="col-lg-4"><h4 class="marked">Stay connected</h4><div class="social-links"><ul><li><a href="https://feeds.feedburner.com/Eprintstacktracenet" target="_blank" rel="noopener" onclick="return window.open(this.href),!1"><span class="fa fa-rss"></span></a></li><li><a href="https://twitter.com/wololock" target="_blank" rel="noopener" onclick="return window.open(this.href),!1"><span class="fa fa-twitter"></span></a></li><li><a href="https://github.com/wololock" target="_blank" rel="noopener" onclick="return window.open(this.href),!1"><span class="fa fa-github"></span></a></li><li><a href="https://stackoverflow.com/users/2194470/szymon-stepniak?tab=profile" target="_blank" rel="noopener" onclick="return window.open(this.href),!1"><span class="fa fa-stack-overflow"></span></a></li><li><a href="https://www.youtube.com/channel/UCEf8e5YAYnowq-2deW4tpsw/featured" target="_blank" rel="noopener" onclick="return window.open(this.href),!1"><span class="fa fa-youtube"></span></a></li><li><a href="mailto:szymon.stepniak@gmail.com" onclick="return window.open(this.href),!1"><span class="fa fa-envelope"></span></a></li><li><a href="https://www.linkedin.com/in/szymon-stępniak-9a0b1630" target="_blank" rel="noopener" onclick="return window.open(this.href),!1"><span class="fa fa-linkedin"></span></a></li><li><a href="https://keybase.io/wololock" target="_blank" rel="noopener" onclick="return window.open(this.href),!1"><span class="fa fa-user-secret"></span></a></li></ul></div><h4 class="marked">Most popular tags</h4><section class="tagcloud"><a href="/tags/affiliate/" style="font-size:12pt;color:#777">affiliate</a> <a href="/tags/async/" style="font-size:8pt;color:#6a6a6a">async</a> <a href="/tags/benchmark/" style="font-size:12pt;color:#777">benchmark</a> <a href="/tags/book/" style="font-size:16pt;color:#858585">book</a> <a href="/tags/cicd/" style="font-size:20pt;color:#929292">cicd</a> <a href="/tags/docker/" style="font-size:12pt;color:#777">docker</a> <a href="/tags/github/" style="font-size:8pt;color:#6a6a6a">github</a> <a href="/tags/graalvm/" style="font-size:24pt;color:#9f9f9f">graalvm</a> <a href="/tags/groovy/" style="font-size:32pt;color:#bababa">groovy</a> <a href="/tags/haskell/" style="font-size:8pt;color:#6a6a6a">haskell</a> <a href="/tags/java/" style="font-size:28pt;color:#adadad">java</a> <a href="/tags/java-8/" style="font-size:8pt;color:#6a6a6a">java-8</a> <a href="/tags/jenkins/" style="font-size:16pt;color:#858585">jenkins</a> <a href="/tags/jenkins-pipeline/" style="font-size:16pt;color:#858585">jenkins-pipeline</a> <a href="/tags/jmh/" style="font-size:16pt;color:#858585">jmh</a> <a href="/tags/junit/" style="font-size:8pt;color:#6a6a6a">junit</a> <a href="/tags/maven/" style="font-size:8pt;color:#6a6a6a">maven</a> <a href="/tags/micronaut/" style="font-size:12pt;color:#777">micronaut</a> <a href="/tags/native-image/" style="font-size:12pt;color:#777">native-image</a> <a href="/tags/non-blocking/" style="font-size:12pt;color:#777">non-blocking</a> <a href="/tags/ratpack/" style="font-size:24pt;color:#9f9f9f">ratpack</a> <a href="/tags/review/" style="font-size:16pt;color:#858585">review</a> <a href="/tags/sdkman/" style="font-size:12pt;color:#777">sdkman</a> <a href="/tags/spock/" style="font-size:12pt;color:#777">spock</a> <a href="/tags/unit-test/" style="font-size:12pt;color:#777">unit-test</a></section></div></div></div></div><div class="row"><div class="col-lg-10 col-lg-offset-1 col-xs-10 col-xs-offset-1 text-center"><ul class="footer-links"><li><a href="/privacy-policy/">Privacy policy</a></li><li><a href="/support-me/">Support me</a></li><li><a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener"><img src="https://badgen.net/badge/license/CC%20BY-NC-SA%204.0/gray"></a></li><li><a href="https://github.com/wololock/wololock.github.io/commits/develop" target="_blank" rel="noopener"><img src="https://badgen.net/github/last-commit/wololock/wololock.github.io?color=blue"></a></li></ul></div></div></div><section class="poweredby"><ul class="text-center"><li><span>Published with </span><a href="https://hexo.io" target="_blank" rel="noopener" onclick="return window.open(this.href),!1"><img src="/img/logo-hexo.png"></a></li><li><span>Hosted on </span><a href="https://github.com/wololock/wololock.github.io" target="_blank" rel="noopener" onclick="return window.open(this.href),!1"><img src="/img/logo-github.png"></a></li><li><span>Deployed with </span><a href="https://circleci.com/gh/wololock/wololock.github.io" target="_blank" rel="noopener" onclick="return window.open(this.href),!1"><img src="/img/logo-circleci.png"></a></li></ul></section></footer><script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script><script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script><script id="cookiebanner" src="//cdnjs.cloudflare.com/ajax/libs/cookie-banner/1.2.2/cookiebanner.min.js" data-moreinfo="/privacy-policy/" data-message="This blog uses cookies to enhance your experience. By continuing to visit it you agree to its use of cookies." data-link="#ffad33" data-font-family="Lora,serif" data-font-size="1.6rem" data-bg="#444"></script><script src="/js/main.js?v=5"></script><script src="/js/highlight.pack.js?v=9.18.1"></script><script>hljs.initHighlightingOnLoad()</script><script>"localhost"!==window.location.hostname&&"127.0.0.1"!==window.location.hostname&&(!function(a,e,t,n,o,c,i){a.GoogleAnalyticsObject=o,a.ga=a.ga||function(){(a.ga.q=a.ga.q||[]).push(arguments)},a.ga.l=1*new Date,c=e.createElement(t),i=e.getElementsByTagName(t)[0],c.async=1,c.src="//www.google-analytics.com/analytics.js",i.parentNode.insertBefore(c,i)}(window,document,"script",0,"ga"),ga("create","UA-42400890-5","auto"),ga("send","pageview"),jQuery("a.ga-track").click(function(a){var e=jQuery(a.target).text();return ga("send","event","affiliate","click",e),!0}))</script></body></html>